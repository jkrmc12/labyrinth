"use strict";
/*
 * Node.js module radiohead-serial
 *
 * Copyright (c) 2017 Peter Müller <peter@crycode.de> (https://crycode.de/)
 *
 * Node.js module for communication between some RadioHead nodes and Node.js using
 * the RH_Serial driver and the RHReliableDatagram manager of the RadioHead library.
 *
 *
 * RadioHead Library (http://www.airspayce.com/mikem/arduino/RadioHead/)
 * Copyright (c) 2014 Mike McCauley
 *
 * Port from native C/C++ code to TypeScript
 * Copyright (c) 2017 Peter Müller <peter@crycode.de> (https://crycode.de/)
 */
/// <reference types="node" />
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const Promise = require("bluebird");
const RH_Serial_1 = require("./RH_Serial");
exports.RH_Serial = RH_Serial_1.RH_Serial;
exports.RH_SERIAL_MAX_PAYLOAD_LEN = RH_Serial_1.RH_SERIAL_MAX_PAYLOAD_LEN;
exports.RH_SERIAL_HEADER_LEN = RH_Serial_1.RH_SERIAL_HEADER_LEN;
exports.RH_SERIAL_MAX_MESSAGE_LEN = RH_Serial_1.RH_SERIAL_MAX_MESSAGE_LEN;
const RHDatagram_1 = require("./RHDatagram");
exports.RHDatagram = RHDatagram_1.RHDatagram;
const RHReliableDatagram_1 = require("./RHReliableDatagram");
exports.RHReliableDatagram = RHReliableDatagram_1.RHReliableDatagram;
exports.RH_FLAGS_ACK = RHReliableDatagram_1.RH_FLAGS_ACK;
exports.RH_DEFAULT_TIMEOUT = RHReliableDatagram_1.RH_DEFAULT_TIMEOUT;
exports.RH_DEFAULT_RETRIES = RHReliableDatagram_1.RH_DEFAULT_RETRIES;
// export the current version of this module
exports.version = '4.0.0';
/** This is the address that indicates a broadcast */
exports.RH_BROADCAST_ADDRESS = 0xff;
exports.RH_FLAGS_RESERVED = 0xf0;
exports.RH_FLAGS_APPLICATION_SPECIFIC = 0x0f;
exports.RH_FLAGS_NONE = 0;
/**
 * The RadioHeasSerial main class for sending and receiving messages through the RadioHead network.
 */
class RadioHeadSerial extends events_1.EventEmitter {
    /**
     * Constructor for a new instance of this class.
     * @param {string}  port     The serial port/device to be used for the communication. (e.g. /dev/ttyUSB0)
     * @param {number}  baud     The baud rate to be used for the communication. (e.g. 9600)
     * @param {number}  address  The address of this node in the RadioHead network. Address range goes from 1 to 254.
     * @param {boolean} reliable (optional) false if RHDatagram should be used instead of RHReliableDatagram. (default true)
     */
    constructor(port, baud, address, reliable = true) {
        super();
        this._reliable = reliable;
        this._driver = new RH_Serial_1.RH_Serial(port, baud);
        // proxy driver errors
        this._driver.on('error', (err) => {
            this.emit('error', err);
        });
        if (this._reliable) {
            this._manager = new RHReliableDatagram_1.RHReliableDatagram(this._driver, address);
        }
        else {
            this._manager = new RHDatagram_1.RHDatagram(this._driver, address);
        }
        this._manager.init()
            .then(() => {
            if (this._reliable) {
                this._manager.on('recvfromAck', (message) => {
                    this.emit('data', message);
                });
            }
            else {
                this._manager.on('recv', (message) => {
                    this.emit('data', message);
                });
            }
            this.emit('init-done');
        })
            .catch((err) => {
            throw err;
        });
    }
    /**
     * Closes the Serialport.
     * After close() is called, no messages can be received.
     * @return {Promise} Promise which will be resolved if the SerialPort is closed.
     */
    close() {
        return this._driver.close();
    }
    /**
     * Send a message through the RadioHead network.
     * @param  {number} to       Recipient address. Use 255 for broadcast messages.
     * @param  {Buffer} data     Buffer containing the message to send.
     * @param  {number} length   Optional number ob bytes to send from the buffer. If not given the whole buffer is sent.
     * @return {Promise}         A Promise which will be resolved when the message has been sent, or rejected in case of an error.
     */
    send(to, data, length) {
        if (!length) {
            length = data.length;
        }
        if (length <= 0) {
            return Promise.reject(new Error('Nothing to send'));
        }
        if (this._reliable) {
            return this._manager.sendtoWait(data, length, to);
        }
        else {
            return this._manager.sendto(data, length, to);
        }
    }
    /**
     * Set the address of this node in the RadioHead network.
     * @param {number} address The new address.
     */
    setAddress(address) {
        this._manager.setThisAddress(address);
    }
    /**
     * Returns the address of this node.
     * @return {number} The address of this node.
     */
    thisAddress() {
        return this._manager.thisAddress();
    }
    /**
     * Sets the maximum number of retries.
     * Defaults to 3 at construction time.
     * If set to 0, each message will only ever be sent once.
     * @param {number} count New number of retries.
     */
    setRetries(count) {
        if (!this._reliable)
            return;
        this._manager.setRetries(count);
    }
    /**
     * Returns the currently configured maximum retries count.
     * Can be changed with setRetries().
     * @return {number} The currently configured maximum retries count.
     */
    getRetries() {
        if (!this._reliable)
            return 0;
        return this._manager.retries();
    }
    /**
     * Sets the minimum retransmit timeout in milliseconds.
     * If an ack is taking longer than this time, a message will be retransmitted.
     * Default is 200.
     * @param {number} timeout New timeout in milliseconds.
     */
    setTimeout(timeout) {
        if (!this._reliable)
            return;
        this._manager.setTimeout(timeout);
    }
    /**
     * Returns the number of retransmissions we have had to send since starting
     * or since the last call to resetRetransmissions().
     * @return {number} The number of retransmissions we have had to send since starting.
     */
    getRetransmissions() {
        if (!this._reliable)
            return 0;
        return this._manager.retransmissions();
    }
    /**
     * Resets the count of the number of retransmissions to 0.
     */
    resetRetransmissions() {
        if (!this._reliable)
            return;
        this._manager.resetRetransmissions();
    }
    /**
     * Tells the receiver to accept messages with any to address, not just messages addressed to this node or the broadcast address.
     * @param {boolean} promiscuous true if you wish to receive messages with any to address. (default false)
     */
    setPromiscuous(promiscuous) {
        this._driver.setPromiscuous(promiscuous);
    }
}
exports.RadioHeadSerial = RadioHeadSerial;
//# sourceMappingURL=radiohead-serial.js.map