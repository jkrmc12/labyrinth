"use strict";
/*
 * Node.js module radiohead-serial
 *
 * Copyright (c) 2017 Peter Müller <peter@crycode.de> (https://crycode.de/)
 *
 * Node.js module for communication between some RadioHead nodes and Node.js using
 * the RH_Serial driver and the RHReliableDatagram manager of the RadioHead library.
 *
 *
 * RadioHead Library (http://www.airspayce.com/mikem/arduino/RadioHead/)
 * Copyright (c) 2014 Mike McCauley
 *
 * Port from native C/C++ code to TypeScript
 * Copyright (c) 2017 Peter Müller <peter@crycode.de> (https://crycode.de/)
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const mocha_typescript_1 = require("mocha-typescript");
const expect = require("expect.js");
const child_process_1 = require("child_process");
const radiohead_serial_1 = require("../src/radiohead-serial");
let socat;
let tty1 = null;
let tty2 = null;
let rhs1 = null;
let rhs2 = null;
//////////////////////////////////////
// Prepare virtual tty's with socat //
//////////////////////////////////////
let SocatPrepare = class SocatPrepare {
    'spawn socat'(done) {
        socat = child_process_1.spawn('socat', ['-d', '-d', 'pty,raw,echo=0', 'pty,raw,echo=0']);
        socat.on('error', (error) => {
            console.log('Error spawning `socat -d -d pty,raw,echo=0 pty,raw,echo=0`!');
            console.log(error);
            done(error);
        });
        socat.stderr.on('data', (data) => {
            let parts = data.toString().split('\n');
            for (let i = 0; i < parts.length; i++) {
                let m = parts[i].match(/PTY is (\/dev.*)$/);
                if (m) {
                    if (tty1 === null) {
                        tty1 = m[1];
                    }
                    else if (tty2 === null) {
                        tty2 = m[1];
                        setTimeout(done, 50);
                    }
                }
            }
        });
    }
    'check the tty\'s created by socat'() {
        expect(tty1).to.match(/^\/dev\/[\/a-zA-Z]+\d+$/);
        expect(tty2).to.match(/^\/dev\/[\/a-zA-Z]+\d+$/);
    }
};
__decorate([
    mocha_typescript_1.test
], SocatPrepare.prototype, "spawn socat", null);
__decorate([
    mocha_typescript_1.test
], SocatPrepare.prototype, "check the tty's created by socat", null);
SocatPrepare = __decorate([
    mocha_typescript_1.suite('prepare virtual tty\'s with socat')
], SocatPrepare);
/////////////////////////////////////////
// Start two RadioHeadSerial instances //
/////////////////////////////////////////
let RHS_Start = class RHS_Start {
    'create rhs1 (address 0x01)'(done) {
        rhs1 = new radiohead_serial_1.RadioHeadSerial(tty1, 9600, 0x01);
        rhs1.on('init-done', () => {
            done();
        });
    }
    'create rhs2 (address 0x02)'(done) {
        rhs2 = new radiohead_serial_1.RadioHeadSerial(tty2, 9600, 0x02);
        rhs2.on('init-done', () => {
            done();
        });
    }
};
__decorate([
    mocha_typescript_1.test
], RHS_Start.prototype, "create rhs1 (address 0x01)", null);
__decorate([
    mocha_typescript_1.test
], RHS_Start.prototype, "create rhs2 (address 0x02)", null);
RHS_Start = __decorate([
    mocha_typescript_1.suite('create the two RadioHeadSerial instances')
], RHS_Start);
///////////////////////////////
// Send and receive messages //
///////////////////////////////
let SendRecv = class SendRecv {
    'from 0x01 to 0x02'(done) {
        const sendData = Buffer.from('Hey beauty!'); // data to be sent
        // function for received messages on rhs2
        let recvListener = (msg) => {
            // remove the listener function from the emitter
            rhs2.removeListener('data', recvListener);
            if (msg.data.compare(sendData) === 0) {
                done();
            }
            else {
                done(new Error('The received data does not match the sent data'));
            }
        };
        // attach the listener function to the emitter
        rhs2.on('data', recvListener);
        // send data
        rhs1.send(0x02, sendData).catch((err) => {
            done(err);
        });
    }
    'from 0x02 to 0x01'(done) {
        const sendData = Buffer.from('Here we go!'); // data to be sent
        // function for received messages on rhs2
        let recvListener = (msg) => {
            // remove the listener function from the emitter
            rhs1.removeListener('data', recvListener);
            if (msg.data.compare(sendData) === 0) {
                done();
            }
            else {
                done(new Error('The received data does not match the sent data'));
            }
        };
        // attach the listener function to the emitter
        rhs1.on('data', recvListener);
        // send data
        rhs2.send(0x01, sendData).catch((err) => {
            done(err);
        });
    }
    'from 0x01 to 0x02 with limited data length'(done) {
        const sendData = Buffer.from('Hey beauty!'); // data to be sent
        // function for received messages on rhs2
        let recvListener = (msg) => {
            // remove the listener function from the emitter
            rhs2.removeListener('data', recvListener);
            let sendDataPart = Buffer.from('Hey');
            if (msg.data.compare(sendDataPart) === 0) {
                done();
            }
            else {
                done(new Error('The received data does not match the sent data'));
            }
        };
        // attach the listener function to the emitter
        rhs2.on('data', recvListener);
        // send data
        rhs1.send(0x02, sendData, 3).catch((err) => {
            done(err);
        });
    }
    'from 0x01 to 0x02 with control characters'(done) {
        const sendData = Buffer.from('abcdef'); // data to be sent
        sendData[1] = 0x02; // STX
        sendData[2] = 0x03; // ETX
        sendData[3] = 0x10; // DLE
        sendData[4] = 0x16; // SYN
        // function for received messages on rhs2
        let recvListener = (msg) => {
            // remove the listener function from the emitter
            rhs2.removeListener('data', recvListener);
            if (msg.data.compare(sendData) === 0) {
                done();
            }
            else {
                done(new Error('The received data does not match the sent data'));
            }
        };
        // attach the listener function to the emitter
        rhs2.on('data', recvListener);
        // send data
        rhs1.send(0x02, sendData).catch((err) => {
            done(err);
        });
    }
    'from 0x01 to broadcast'(done) {
        const sendData = Buffer.from('Hey beauty!'); // data to be sent
        // function for received messages on rhs2
        let recvListener = (msg) => {
            // remove the listener function from the emitter
            rhs2.removeListener('data', recvListener);
            if (msg.headerTo !== radiohead_serial_1.RH_BROADCAST_ADDRESS) {
                done(new Error('The headerTo does not RH_BROADCAST_ADDRESS'));
                return;
            }
            if (msg.data.compare(sendData) === 0) {
                done();
            }
            else {
                done(new Error('The received data does not match the sent data'));
            }
        };
        // attach the listener function to the emitter
        rhs2.on('data', recvListener);
        // send data
        rhs1.send(radiohead_serial_1.RH_BROADCAST_ADDRESS, sendData).catch((err) => {
            done(err);
        });
    }
    'from 0x01 to 0x42 should fail'(done) {
        const sendData = Buffer.from('Hey beauty!'); // data to be sent
        // send data
        rhs1.send(0x42, sendData).catch((err) => {
            done();
        });
    }
};
__decorate([
    mocha_typescript_1.test
], SendRecv.prototype, "from 0x01 to 0x02", null);
__decorate([
    mocha_typescript_1.test
], SendRecv.prototype, "from 0x02 to 0x01", null);
__decorate([
    mocha_typescript_1.test
], SendRecv.prototype, "from 0x01 to 0x02 with limited data length", null);
__decorate([
    mocha_typescript_1.test
], SendRecv.prototype, "from 0x01 to 0x02 with control characters", null);
__decorate([
    mocha_typescript_1.test
], SendRecv.prototype, "from 0x01 to broadcast", null);
__decorate([
    mocha_typescript_1.test
], SendRecv.prototype, "from 0x01 to 0x42 should fail", null);
SendRecv = __decorate([
    mocha_typescript_1.suite('send and receive messages')
], SendRecv);
let TestFunctions = class TestFunctions {
    'setAddress(0x05)'() {
        rhs2.setAddress(0x05);
    }
    'thisAddress()'(done) {
        if (rhs2.thisAddress() === 0x05) {
            done();
        }
        else {
            done(new Error('thisAddress() did not report the set address'));
        }
    }
    'setRetries(7)'() {
        rhs1.setRetries(7);
    }
    'getRetries()'(done) {
        if (rhs1.getRetries() === 7) {
            done();
        }
        else {
            done(new Error('getRetries() did not report the set number of retries'));
        }
    }
    'setTimeout(100)'() {
        rhs1.setTimeout(100);
    }
    'getRetransmissions()'() {
        let retransmissions = rhs1.getRetransmissions();
        expect(retransmissions).to.be.a('number');
    }
    'resetRetransmissions()'() {
        rhs1.resetRetransmissions();
    }
    'setPromiscuous(true)'() {
        rhs1.setPromiscuous(true);
    }
};
__decorate([
    mocha_typescript_1.test
], TestFunctions.prototype, "setAddress(0x05)", null);
__decorate([
    mocha_typescript_1.test
], TestFunctions.prototype, "thisAddress()", null);
__decorate([
    mocha_typescript_1.test
], TestFunctions.prototype, "setRetries(7)", null);
__decorate([
    mocha_typescript_1.test
], TestFunctions.prototype, "getRetries()", null);
__decorate([
    mocha_typescript_1.test
], TestFunctions.prototype, "setTimeout(100)", null);
__decorate([
    mocha_typescript_1.test
], TestFunctions.prototype, "getRetransmissions()", null);
__decorate([
    mocha_typescript_1.test
], TestFunctions.prototype, "resetRetransmissions()", null);
__decorate([
    mocha_typescript_1.test
], TestFunctions.prototype, "setPromiscuous(true)", null);
TestFunctions = __decorate([
    mocha_typescript_1.suite('test functions')
], TestFunctions);
///////////////////////////////
// Send and receive messages //
///////////////////////////////
let SendRecv2 = class SendRecv2 {
    'from 0x01 to 0x05'(done) {
        const sendData = Buffer.from('Hey beauty!'); // data to be sent
        // function for received messages on rhs2
        let recvListener = (msg) => {
            // remove the listener function from the emitter
            rhs2.removeListener('data', recvListener);
            if (msg.data.compare(sendData) === 0) {
                done();
            }
            else {
                done(new Error('The received data does not match the sent data'));
            }
        };
        // attach the listener function to the emitter
        rhs2.on('data', recvListener);
        // send data
        rhs1.send(0x05, sendData).catch((err) => {
            done(err);
        });
    }
    'from 0x05 to 0x42 (0x01 with promiscuous mode)'(done) {
        const sendData = Buffer.from('Hey beauty!'); // data to be sent
        // function for received messages on rhs2
        let recvListener = (msg) => {
            // remove the listener function from the emitter
            rhs1.removeListener('data', recvListener);
            if (msg.data.compare(sendData) === 0) {
                done();
            }
            else {
                done(new Error('The received data does not match the sent data'));
            }
        };
        // attach the listener function to the emitter
        rhs1.on('data', recvListener);
        // send data
        rhs2.send(0x42, sendData).catch((err) => {
            done(err);
        });
    }
};
__decorate([
    mocha_typescript_1.test
], SendRecv2.prototype, "from 0x01 to 0x05", null);
__decorate([
    mocha_typescript_1.test
], SendRecv2.prototype, "from 0x05 to 0x42 (0x01 with promiscuous mode)", null);
SendRecv2 = __decorate([
    mocha_typescript_1.suite('send and receive messages')
], SendRecv2);
/////////////
// Cleanup //
/////////////
let Cleanup = class Cleanup {
    'kill socat'(done) {
        socat.on('close', (code) => {
            done();
        });
        socat.kill();
    }
};
__decorate([
    mocha_typescript_1.test
], Cleanup.prototype, "kill socat", null);
Cleanup = __decorate([
    mocha_typescript_1.suite('cleanup')
], Cleanup);
//# sourceMappingURL=radiohead-serial-test.js.map