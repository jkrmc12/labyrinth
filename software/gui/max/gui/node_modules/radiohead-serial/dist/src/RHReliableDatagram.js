"use strict";
/*
 * Node.js module radiohead-serial
 *
 * RadioHead Library (http://www.airspayce.com/mikem/arduino/RadioHead/)
 * Copyright (c) 2014 Mike McCauley
 *
 * Port from native C/C++ code to TypeScript
 * Copyright (c) 2017 Peter MÃ¼ller <peter@crycode.de> (https://crycode.de/)
 */
/// <reference types="node" />
Object.defineProperty(exports, "__esModule", { value: true });
const Promise = require("bluebird");
const radiohead_serial_1 = require("./radiohead-serial");
const RHDatagram_1 = require("./RHDatagram");
/**
 * The acknowledgement bit in the FLAGS.
 */
exports.RH_FLAGS_ACK = 0x80;
/**
 * The default retry timeout in milliseconds.
 */
exports.RH_DEFAULT_TIMEOUT = 200;
/**
 * The default number of retries.
 */
exports.RH_DEFAULT_RETRIES = 3;
/**
 * RHDatagram subclass for sending addressed, acknowledged, retransmitted datagrams.
 */
class RHReliableDatagram extends RHDatagram_1.RHDatagram {
    /**
     * Constructor.
     * @param  {RH_Serial} driver      The RadioHead driver to use to transport messages.
     * @param  {number}    thisAddress The address to assign to this node.
     */
    constructor(driver, thisAddress) {
        super(driver, thisAddress);
        this._retransmissions = 0;
        this._lastSequenceNumber = 0;
        this._timeout = exports.RH_DEFAULT_TIMEOUT;
        this._retries = exports.RH_DEFAULT_RETRIES;
        this._seenIds = [];
        for (let i = 0; i < 256; i++) {
            this._seenIds[i] = 0;
        }
    }
    /**
     * Initialise this manager class.
     * @return {Promise}
     */
    init() {
        return super.init()
            .then(() => {
            // ack messages
            this.on('recv', this._recvfromAckHandler.bind(this));
        });
    }
    /**
     * Handler for received messages.
     * This sends ack messages and emits the recvfromAck event.
     * @param {RecvMessage} msg The received message to handle.
     */
    _recvfromAckHandler(msg) {
        // Never ACK an ACK
        if (!(msg.headerFlags & exports.RH_FLAGS_ACK)) {
            // Its a normal message not an ACK
            if (msg.headerTo === this._thisAddress) {
                // Its for this node and
                // Its not a broadcast, so ACK it
                // Acknowledge message with ACK set in flags and ID set to received ID
                this.acknowledge(msg.headerId, msg.headerFrom);
            }
            // If we have not seen this message before, then we are interested in it
            if (msg.headerId !== this._seenIds[msg.headerFrom]) {
                // emit event for new message
                this.emit('recvfromAck', msg);
                this._seenIds[msg.headerFrom] = msg.headerId;
            }
            // Else just re-ack it
        }
    }
    /**
     * Sets the minimum retransmit timeout. If sendtoWait is waiting for an ack
     * longer than this time (in milliseconds),
     * it will retransmit the message. Defaults to 200ms. The timeout is measured from the end of
     * transmission of the message. It must be at least longer than the the transmit
     * time of the acknowledgement (preamble+6 octets) plus the latency/poll time of the receiver.
     * For fast modulation schemes you can considerably shorten this time.
     * Caution: if you are using slow packet rates and long packets
     * you may need to change the timeout for reliable operations.
     * The actual timeout is randomly varied between timeout and timeout*2.
     * @param {number} timeout The new timeout period in milliseconds
     */
    setTimeout(timeout) {
        this._timeout = timeout;
    }
    /**
     * Sets the maximum number of retries. Defaults to 3 at construction time.
     * If set to 0, each message will only ever be sent once.
     * sendtoWait will give up and reject if there is no ack received after all transmissions time out
     * and the retries count is exhausted.
     * @param  {number} retries The maximum number a retries.
     */
    setRetries(retries) {
        this._retries = retries;
    }
    /**
     * Returns the currently configured maximum retries count.
     * Can be changed with setRetries().
     * @return {number} The currently configured maximum number of retries.
     */
    retries() {
        return this._retries;
    }
    /**
     * Send the message (with retries) and waits for an ack. Resolves true if an acknowledgement is received.
     * Rejects if all retries are exhausted (ie up to retries*timeout milliseconds).
     * If the destination address is the broadcast address RH_BROADCAST_ADDRESS (255), the message will
     * be sent as a broadcast, but receiving nodes do not acknowledge, and sendtoWait() resolves immediately
     * without waiting for any acknowledgements.
     * @param  {Buffer}  buf     The buffer to send.
     * @param  {number}  len     Length of the buffer to send.
     * @param  {number}  address The address to send the message to.
     * @return {Promise}
     */
    sendtoWait(buf, len, address) {
        return new Promise((resolve, reject) => {
            // Assemble the message
            let thisSequenceNumber = ++this._lastSequenceNumber;
            let retries = 0;
            // promise chain loop with the retries
            let prom;
            let succeeded = () => {
                // _sendtoWaitOne succeeded
                resolve();
            };
            let failed = (_err) => {
                // _sendtoWaitOne failed
                if (retries++ <= this._retries) {
                    // retry
                    this._retransmissions++;
                    prom.then(() => {
                        return this._sendtoWaitOne(buf, len, address, thisSequenceNumber).then(succeeded).catch(failed);
                    });
                }
                else {
                    // max retries reached
                    reject(new Error('sendtoWait failed'));
                }
            };
            prom = this._sendtoWaitOne(buf, len, address, thisSequenceNumber).then(succeeded).catch(failed);
        });
    }
    /**
     * Internal helper function for sendtoWait().
     * @param  {Buffer}  buf     The buffer to send.
     * @param  {number}  len     Length of the buffer to send.
     * @param  {number}  address The address to send the message to.
     * @param  {number}  thisSequenceNumber The headerId for the message.
     * @return {Promise}
     */
    _sendtoWaitOne(buf, len, address, thisSequenceNumber) {
        return new Promise((resolve, reject) => {
            this.setHeaderId(thisSequenceNumber);
            this.setHeaderFlags(radiohead_serial_1.RH_FLAGS_NONE, exports.RH_FLAGS_ACK); // Clear the ACK flag
            this.sendto(buf, len, address)
                // sendto succeeded
                .then(() => {
                // Never wait for ACKS to broadcasts:
                if (address === radiohead_serial_1.RH_BROADCAST_ADDRESS) {
                    resolve();
                    return;
                }
                // variable for the ack timeout
                let ackTimeout = null;
                // on ack listener
                let ackListener = (msg) => {
                    if (msg.headerFrom === address
                        && msg.headerTo === this._thisAddress
                        && (msg.headerFlags & exports.RH_FLAGS_ACK)
                        && msg.headerId === thisSequenceNumber) {
                        // ack received
                        // clear timeout, remove listener and resolve
                        clearTimeout(ackTimeout);
                        this.removeListener('recv', ackListener);
                        resolve();
                    }
                };
                this.on('recv', ackListener);
                // Compute a new timeout, random between _timeout and _timeout*2
                // This is to prevent collisions on every retransmit
                // if 2 nodes try to transmit at the same time
                let timeout = this._timeout + Math.floor(Math.random() * this._timeout);
                // set ack timeout
                ackTimeout = setTimeout(() => {
                    // ack timed out
                    // remove listener and reject
                    this.removeListener('recv', ackListener);
                    reject(new Error('ACK timeout'));
                }, timeout);
            })
                // sendto failed
                .catch((err) => {
                reject(err);
            });
        });
    }
    /**
     * Returns the number of retransmissions
     *  we have had to send since starting or since the last call to resetRetransmissions().
     * @return {number} The number of retransmissions since initialisation.
     */
    retransmissions() {
        return this._retransmissions;
    }
    /**
     * Resets the count of the number of retransmissions to 0.
     */
    resetRetransmissions() {
        this._retransmissions = 0;
    }
    /**
     * Send an ACK for the message id to the given from address
     * @param  {number} id   The id of the message
     * @param  {number} from From address of the message
     */
    acknowledge(id, from) {
        this.setHeaderId(id);
        this.setHeaderFlags(exports.RH_FLAGS_ACK);
        return this.sendto(Buffer.from('!'), 1, from);
    }
}
exports.RHReliableDatagram = RHReliableDatagram;
//# sourceMappingURL=RHReliableDatagram.js.map